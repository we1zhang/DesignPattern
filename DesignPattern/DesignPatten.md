# 设计模式

[TOC]





### 策略模式（Strategy Pattern）

定义：策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。



###观察者模式（Observer Pattern）

定义：观察者模式定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。



### 装饰者模式（Decorator Pattern）

定义：装饰者动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。



### 单件模式（Singleton Pattern）

定义：确保一个类只有一个实例，并提供一个全局访问点。



### 代理模式（Proxy Pattern）

定义：代理模式是给一个对象提供一个代理对象，并由代理对象来控制对原对象的引用。

* **静态代理**

  优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。

  缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。  

* **动态代理**：真正的代理对象由JDK在运行时通过反射机制动动态的来创建。

* **cglib代理**：CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。 

  CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。 

